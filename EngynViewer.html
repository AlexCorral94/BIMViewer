<!DOCTYPE html>
<html>
<head>
    <title>07.01 - Load JSON Model</title>
    <script src="libs/three.js"></script>
    <script src="libs/dat.gui.min.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/LegacyJSONLoader.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/WebGL.js"></script>
    <script src="libs/TrackballControls.js"></script>
    <script src="libs/BufferGeometryUtils.js"></script>
    <script src="libs/Projector.js"></script>

    

    <script type="x-shader/x-vertex" id="vertexShader">
			varying vec3 vWorldPosition;
			void main() {
				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">
			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;
			varying vec3 vWorldPosition;
			void main() {
				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );
			}
		</script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<script>

  // global variables
  var renderer, scene, camera;
    var control, stats, controls;
    var maxdistance, modelo;
    var spotLight, gridHelper;

    var _mouse = { x: 0, y: 0 },
			    objects = [],
			    _projector = new THREE.Projector();
    /**
     * Initializes the scene, camera and objects. Called when the window is
     * loaded by using window.onload (see below)
     */
    function init() {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new THREE.Scene();
        maxdistance = 100000;
        
        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 15, maxdistance*2);
        camera.position.x = maxdistance*0.5;
        camera.position.y = maxdistance*0.5;
        camera.position.z = maxdistance;

        // create a render, sets the background color and the size
        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
        renderer.setClearColor(0x000000, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild( renderer.domElement );
        renderer.shadowMap.Enabled;


        //Create controls to enable pan y zoom
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.addEventListener( 'change', render );
        controls.enableZoom = true;
        controls.minDistance = 20;
        controls.maxDistance = maxdistance;
        controls.enablePan = true;
   
        //Add a HemisphereLight
        var hemisphereLight = new THREE.HemisphereLight(0xfffafa,0x000000, .9)
        scene.add(hemisphereLight);

        //Add a directional light
        spotLight = new THREE.DirectionalLight( 0xD9FBFF, 0.9 );
        spotLight.position.set( 30,10,-10 );
        spotLight.castShadow = true;
        spotLight.shadow.bias = 0.1;
        spotLight.shadow.mapSize.width = maxdistance;
        spotLight.shadow.mapSize.height = maxdistance;
        spotLight.shadow.camera.right = maxdistance;
        spotLight.shadow.camera.left = maxdistance*-1;
        spotLight.shadow.camera.top = maxdistance;
        spotLight.shadow.camera.bottom = maxdistance*-1;
        spotLight.shadow.camera.far = maxdistance;
        spotLight.shadow.camera.near = 0.1;
        scene.add( spotLight )

        

        //Add gridline
        gridHelper = new THREE.GridHelper( 50000, 1000 );
        gridHelper.visible = false;
        scene.add( gridHelper );


        //SKYDOME
        var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				var uniforms = {
					topColor: { type: "c", value: new THREE.Color( 0xd9e9f9 ) },
					bottomColor: { type: "c", value: new THREE.Color( 0xefefef ) },
					offset: { type: "f", value: 400 },
					exponent: { type: "f", value: 0.6 }
				};
				uniforms.topColor.value.copy( spotLight.color );
				
        var skyGeo = new THREE.SphereGeometry( maxdistance, 32, 15 );
				var skyMat = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
					side: THREE.BackSide
                    
				} );
				var sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(20, 20);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;

        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = 0;
        plane.position.y = -2;
        plane.position.z = 0;

      
        // add extras
        addStatsObject();

        // loadModel();
        loadModel();


        animate();

        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);

        render();

        addControlGui();

        controls.update();
     
    }


    document.addEventListener( 'click', onDocumentMouseDown, false );


    var elementCol;
    var elemetOpa;
    var objectSel;
    var elementtransparent;

function onDocumentMouseDown( event ) {

    event.preventDefault();
    
    // find intersections
    _mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    _mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    
    var vector = new THREE.Vector3( _mouse.x, _mouse.y, 1 );
    vector.unproject( camera );

    var ray = new THREE.Raycaster( camera.position, vector.sub(camera.position ).normalize() );
    
    //var ray = _projector.pickingRay( vector, camera );

    var intersects = ray.intersectObjects( scene.children, true);

    

    if ( intersects.length > 0 ) {
            
            if(objectSel != undefined){

                objectSel.material.color.setHex(elementCol);
                objectSel.material.opacity = elemetOpa;
                objectSel.material.transparent = elementtransparent;
                //alert(elementCol);
            }
            elementCol = intersects[ 0 ].object.material.color.getHex();
            elemetOpa = intersects[ 0 ].object.material.opacity;
            elementtransparent = intersects[ 0 ].object.material.transparent;

            intersects[ 0 ].object.material.color.setHex( 0x0033cc );
            intersects[ 0 ].object.material.opacity = 0.5;
            intersects[ 0 ].object.material.transparent = true;
            alert(intersects[ 0 ].object.uuid);
            
            
            objectSel = intersects[ 0 ].object;
    }	
}


    //Load customized Json file
    function loadModel() {
        var loader = new THREE.ObjectLoader();
        loader.load("assets/models/exported/HouseRevit1.js",
            function (model) {
            model.castShadow = true;
            // var helper = new THREE.EdgesHelper( model, 0xffffff );
            // helper.material.linewidth = 2;
            // scene.add(helper);

            //var edges = new THREE.EdgesGeometry( model );
            //var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0xffffff } ) );
            // scene.add( line );

            scene.add(model);         
        });
        
    }
    


          
            // var boundingBox = new THREE.Box3().setFromObject(model);
            // var boundingValues = [Math.abs(boundingBox.min.x), Math.abs(boundingBox.max.x), 
            // Math.abs(boundingBox.min.y), Math.abs(boundingBox.max.y), 
            // Math.abs(boundingBox.min.z), Math.abs(boundingBox.max.z)]; 
            // largest = Math.max.apply(Math, boundingValues);
             



            
    function addControlGui() {
        var gui = new dat.GUI();
        
        var params = {
					intensity: spotLight.intensity,
				};
        gui.add( params, 'intensity', 0, 2 ).onChange( function ( val ) {
					spotLight.intensity = val;
					render();
				} );

        var props = {
	                hideBars: gridHelper.visible,
				};
         gui.add(props,'hideBars').name('Grid').onChange( function ( val ) {
					gridHelper.visible = val;
                    render();
                } );
        
    }

    function addStatsObject() {
        stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.body.appendChild( stats.domElement );
    }

    /**
     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame
     * for future renders
     */
    function render() {

        // update stats
        stats.update();

        // and render the scene
        renderer.render(scene, camera);

        // render using requestAnimationFrame
        //requestAnimationFrame(render);
    }

    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame( animate );
        // required if controls.enableDamping or controls.autoRotate are set to true
        controls.update();
        renderer.render( scene, camera );
    }

 
    // calls the init function when the window is done loading.
    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

</script>
<body>
</body>
</html>