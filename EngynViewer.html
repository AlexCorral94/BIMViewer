<!DOCTYPE html>
<html>
<head>
    <title>07.01 - Load JSON Model</title>
    <script src="libs/three.js"></script>
    <script src="libs/dat.gui.min.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/LegacyJSONLoader.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/WebGL.js"></script>
    <script src="libs/TrackballControls.js"></script>
    <script src="libs/BufferGeometryUtils.js"></script>
    <script src="libs/Projector.js"></script>
    <script src="js/Properties.js"></script>
    <script src="js/StaticVariables.js"></script>
    

    <script type="x-shader/x-vertex" id="vertexShader">
			varying vec3 vWorldPosition;
			void main() {
				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">
			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;
			varying vec3 vWorldPosition;
			void main() {
				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );
			}
		</script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<script>

  // global variables
    var renderer, scene, camera;
    var control, stats, controls;
    var spotLight, gridHelper, modelo;
    var oringinMaterial;
    var elementtransparent;
    var maxdistance = 100000;
    var mindistance = 1;
    var modelLocation = "assets/models/exported/HouseRevit1.js";
    var objectSel = null;
    var currentElm = null;
    var userInterface;
    var gui1_X;

    var Object3D = {
        Name: "Test"};


    var _mouse = { x: 0, y: 0 },
			    objects = [],
			    _projector = new THREE.Projector();
    /**
     * Initializes the scene, camera and objects. Called when the window is
     * loaded by using window.onload (see below)
     */
    function init() {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new THREE.Scene();
        
        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, mindistance*0.9, maxdistance*2.2);
        
        camera.position.x = maxdistance*0.5;
        camera.position.y = maxdistance*0.5;
        camera.position.z = maxdistance;
        

        // create a render, sets the background color and the size
        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
        renderer.setClearColor(0x000000, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild( renderer.domElement );
        renderer.shadowMap.Enabled;


        //Create controls to enable pan y zoom
        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.addEventListener( 'change', render );
        controls.enableZoom = true;
        controls.minDistance = mindistance;
        controls.maxDistance = maxdistance;
        controls.enablePan = true;
   
        //Add a HemisphereLight
        var hemisphereLight = new THREE.HemisphereLight(0xfffafa,0x000000, .9)
        scene.add(hemisphereLight);

        //Add a directional light
        spotLight = new THREE.DirectionalLight( 0xD9FBFF, 0.9 );
        spotLight.position.set( 30,10,-10 );
        spotLight.castShadow = true;
        spotLight.shadow.bias = 0.1;
        spotLight.shadow.mapSize.width = maxdistance;
        spotLight.shadow.mapSize.height = maxdistance;
        spotLight.shadow.camera.right = maxdistance;
        spotLight.shadow.camera.left = maxdistance*-1;
        spotLight.shadow.camera.top = maxdistance;
        spotLight.shadow.camera.bottom = maxdistance*-1;
        spotLight.shadow.camera.far = maxdistance;
        spotLight.shadow.camera.near = 0.1;
        scene.add( spotLight )
 
        //Add gridline
        gridHelper = new THREE.GridHelper( 5000, 100 );
        gridHelper.visible = false;
        scene.add( gridHelper );

        //SKYDOME
        var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				var uniforms = {
					topColor: { type: "c", value: new THREE.Color( 0xd9e9f9 ) },
					bottomColor: { type: "c", value: new THREE.Color( 0xefefef ) },
					offset: { type: "f", value: 400 },
					exponent: { type: "f", value: 0.6 }
				};
				uniforms.topColor.value.copy( spotLight.color );
				
        var skyGeo = new THREE.SphereGeometry( maxdistance, 32, 15 );
				var skyMat = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
					side: THREE.BackSide
                    
				} );
				var sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );

        // create the ground plane
        var planeGeometry = new THREE.PlaneGeometry(20, 20);
        var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.receiveShadow = true;

        // rotate and position the plane
        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = 0;
        plane.position.y = -2;
        plane.position.z = 0;

      
        // add extras
        addStatsObject();

        // loadModel();
        loadModel();

        animate();

        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);
        render();

        var gui = new dat.GUI();
    var f1 = gui.addFolder('Configuration');
    var params = {
                intensity: spotLight.intensity,
            };
    f1.add( params, 'intensity', 0, 2 ).onChange( function ( val ) {
                spotLight.intensity = val;
                render();
            } );
  
    gui1_X = gui.add(Object3D, 'Name').listen();

        // addControlGui(Object3D);
        controls.update();

    }

    //Selects an element when double clicking
    document.addEventListener( 'dblclick', onDocumentMouseDown, false );

    
    //Define function when an element is double clicked
    function onDocumentMouseDown( event ) {

        event.preventDefault();    
        // find intersections
        _mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        _mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    
        var vector = new THREE.Vector3( _mouse.x, _mouse.y, 1 );
        vector.unproject( camera );
        var ray = new THREE.Raycaster( camera.position, vector.sub(camera.position ).normalize() );
        var intersects = ray.intersectObjects( scene.children, true);
        
        //Get object 3D
        currentElm = scene.getObjectByName(intersects[ 0 ].object.name);

        if ( intersects.length > 0 ) {  
            if(objectSel != undefined){

                objectSel.material = oringinMaterial;
            }
            oringinMaterial = intersects[ 0 ].object.material;
            intersects[ 0 ].object.material = Selmaterial;          
            objectSel = intersects[ 0 ].object;
        }	
        
        Object3D.Name = objectSel.name;
        gui1_X.updateDisplay();
    }

    //Remove element from scene
    function removeEntity(object) {
        var selectedObject = scene.getObjectByName(object.name);
        selectedObject.parent.remove( selectedObject );
    }

    //Remove element when delete key is pressed
    document.addEventListener('keydown', function(event) {
        if (event.code == 'Delete') {
            if(objectSel != null){
            removeEntity(objectSel);
            }
            objectSel = null;
        }
    });

    //Load customized Json file
    function loadModel() {
        var loader = new THREE.ObjectLoader();
        loader.load(modelLocation,
            function (model) {
            model.castShadow = true;
                
            // var helper = new THREE.EdgesHelper( model, 0xffffff );
            // helper.material.linewidth = 2;
            // scene.add(helper);

            //Add edges to each element
            // edges = new THREE.EdgesHelper( mesh, 0xEA25E8 );
            // edges.matrixAutoUpdate = true;
            // edges.material.linewidth = 1500;
            // scene.add( edges );
            
            model.scale.set( 0.1, 0.1, 0.1 );

            //Adjust the camera location to the max bouding from object
            var bbox = new THREE.Box3().setFromObject(model);
            var maxObjectDistance = Math.max(bbox.max.z, bbox.max.x, bbox.max.y);
            camera.position.z = maxObjectDistance
            camera.position.x = bbox.max.x;
            camera.position.y = bbox.max.y;

            //Adjust the camera near plane and max/min zoom for controls
            var averageSizes = ((bbox.max.z + bbox.max.x +  bbox.max.y)/3)*0.01;
            camera.near = averageSizes;
            controls.minDistance = averageSizes*1.2;
            controls.maxDistance = maxObjectDistance*4;
            camera.updateProjectionMatrix();
            
            scene.add(model);         
        });     
    }
    
    function addStatsObject() {
        stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.body.appendChild( stats.domElement );
    }

    /**
     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame
     * for future renders
     */
    function render() {

        // update stats
        stats.update();

        // and render the scene
        renderer.render(scene, camera);

        // render using requestAnimationFrame
        //requestAnimationFrame(render);
    }

    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame( animate );
        // required if controls.enableDamping or controls.autoRotate are set to true
        controls.update();
        renderer.render( scene, camera );
    }

 
    // calls the init function when the window is done loading.
    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

    
</script>
<body>
</body>
</html>